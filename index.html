<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>æš—è¨˜ã‚¢ãƒ—ãƒª v.0.1</title>
  
  <!-- Excelèª­ã¿è¾¼ã¿ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (SheetJS) -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

  <style>
    /* --- style.css --- */
    body {
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: #f5f5f5;
      touch-action: none;
    }

    #app {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 100vh;
      width: 100vw;
      padding-top: 20px;
      box-sizing: border-box;
      position: relative;
    }

    .hidden {
      display: none !important;
    }

    /* --- æˆ»ã‚‹ãƒœã‚¿ãƒ³ --- */
    .back-button-container {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
    }
    .back-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      font-weight: bold;
      color: #333;
    }

    /* --- ã‚«ãƒ¼ãƒ‰ã®ãƒ‡ã‚¶ã‚¤ãƒ³ --- */
    .card {
      background: white;
      width: 85%;
      max-width: 400px;
      height: auto;
      max-height: 75vh; 
      min-height: 200px;
      padding: 32px 24px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      cursor: pointer;
      touch-action: none;
      user-select: none;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      position: relative;
      margin-top: 5vh;
      overflow-y: auto;
    }

    .question {
      font-size: 1.4rem;
      font-weight: bold;
      margin-bottom: 24px;
      text-align: left;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .answer {
      font-size: 1.1rem;
      color: #444;
      border-top: 2px solid #f0f0f0;
      padding-top: 20px;
      text-align: left;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    .card-stats-debug {
      font-size: 0.75rem;
      color: #aaa;
      margin-bottom: 10px;
      text-align: right;
      font-family: monospace;
    }

    /* --- ãƒ•ã‚©ãƒ«ãƒ€é¸æŠç”»é¢ --- */
    .path-browser {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      padding: 60px 20px 20px 20px;
      box-sizing: border-box;
      padding-bottom: 80px;
    }

    .folder-row {
      background: white;
      margin: 6px 0;
      border-bottom: 1px solid #eee;
      border-radius: 8px;
      transition: background 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
    }

    .folder-info {
      flex-grow: 1;
      padding: 12px;
      cursor: pointer;
    }

    .folder-row:active {
      background: #f0f0f0;
    }

    .kebab-container {
      position: relative;
      height: 100%;
      display: flex;
      align-items: center;
    }

    .kebab-btn {
      font-size: 1.2rem;
      padding: 10px 15px;
      color: #888;
      cursor: pointer;
      line-height: 1;
    }
    
    .menu-popup {
      position: absolute;
      top: 100%;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 2000;
      min-width: 120px;
      display: none; 
      overflow: hidden;
    }

    .menu-popup.show {
      display: block;
    }

    .menu-item {
      padding: 12px 16px;
      font-size: 0.95rem;
      color: #333;
      cursor: pointer;
      border-bottom: 1px solid #f5f5f5;
    }
    .menu-item:last-child {
      border-bottom: none;
    }

    /* --- å•é¡Œä¸€è¦§ç”»é¢ --- */
    .card-list-view {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      padding: 60px 20px 20px 20px;
      box-sizing: border-box;
      background: white;
    }
    
    .list-header {
      font-weight: bold;
      margin-bottom: 20px;
      font-size: 1.2rem;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }

    .list-item {
      border-bottom: 1px solid #eee;
      padding: 12px 0;
    }
    
    .list-q {
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }
    .list-a {
      color: #666;
      font-size: 0.9rem;
    }

    html, body { height: 100%; margin: 0; overscroll-behavior: none; touch-action: none; }
    body { overflow: hidden; }

    /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
    #toolbar {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        display: none;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
    }

    .tool-btn {
        background: rgba(255, 255, 255, 0.95);
        padding: 6px 10px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        font-size: 0.8rem;
        cursor: pointer;
        border: 1px solid #ddd;
        display: flex;
        align-items: center;
        justify-content: center;
        white-space: nowrap;
    }

    /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€š */
    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 3000;
      display: flex; justify-content: center; align-items: center;
    }
    .modal-content {
      background: white; padding: 20px; border-radius: 12px;
      width: 90%; max-width: 500px; max-height: 85vh; overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      display: flex; flex-direction: column;
    }
    .modal-title { font-weight: bold; font-size: 1.2rem; margin-bottom: 15px; }
    
    .config-label {
      display: block; margin-bottom: 15px; font-weight: bold; font-size: 0.95rem;
    }
    .config-label input {
      display: block; width: 100%; padding: 8px; margin-top: 5px;
      box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem;
    }
    .config-desc { font-weight: normal; font-size: 0.8rem; color: #666; margin-top: 3px; }

    .modal-actions {
      display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;
    }
    .btn-primary {
      background: #333; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;
    }
    .btn-secondary {
      background: #eee; color: #333; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;
    }
    .btn-danger {
      background: #d32f2f; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;
    }
    
    /* Sync Modal Styles */
    .sync-area {
        border: 1px dashed #ccc;
        padding: 20px;
        margin-bottom: 15px;
        text-align: center;
        border-radius: 8px;
        background: #fafafa;
    }
    .sync-desc {
        font-size: 0.85rem;
        color: #666;
        margin-bottom: 10px;
    }
    .gh-config-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 2px solid #eee;
    }

    /* Debug Modal Styles */
    #debugText {
      flex: 1;
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      font-family: monospace;
      font-size: 12px;
      white-space: pre;
      overflow: auto;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f8f8f8;
      color: #333;
    }
  </style>
</head>
<body>

  <!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
  <div id="toolbar">
    <div class="tool-btn" id="configBtn">ğŸ”§ è¨­å®š</div>
    <div class="tool-btn" id="syncBtn">ğŸ”„ åŒæœŸ</div>
    <div class="tool-btn" id="debugBtn">ğŸ DB</div>
    <div class="tool-btn">
      <span style="font-weight:bold; margin-right:5px;">Excel:</span>
      <input type="file" id="tsvInput" accept=".xlsx, .xls" style="width:170px;" />
    </div>
  </div>

  <main id="app"></main>

  <!-- è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="configModal" class="modal-overlay hidden">
    <div class="modal-content">
      <div class="modal-title">ã‚¢ãƒ—ãƒªè¨­å®š</div>
      
      <div style="font-weight:bold; margin-top:15px; border-bottom:1px solid #eee;">å­¦ç¿’ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡</div>
      <label class="config-label">
        å­¦ç¿’ä¸­ã®åŒæ™‚é€²è¡Œæ•° (Learning Threshold)
        <input type="number" id="cfgLearningThreshold" min="1" max="100">
      </label>
      <label class="config-label">
        æ¨å®šèª¤ç­”æ•°ã®è¨±å®¹ä¸Šé™ (Likely Wrong Limit)
        <input type="number" id="cfgLikelyWrongLimit" min="0" max="50">
      </label>

      <div style="font-weight:bold; margin-top:15px; border-bottom:1px solid #eee;">è¨˜æ†¶ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</div>
      <label class="config-label">
        Mu Base (ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒã‚¤ã‚¢ã‚¹)
        <input type="number" id="cfgMuBase" step="0.1">
        <div class="config-desc">åŸºæº–ã¨ãªã‚‹æ­£ç­”å‚¾å‘ã€‚é«˜ã„ã»ã©æ­£ç­”ç‡ãŒé«˜ããªã‚Šã¾ã™ã€‚</div>
      </label>
      <label class="config-label">
        Alpha (å­¦ç¿’ç‡)
        <input type="number" id="cfgAlpha" step="0.01" min="0">
        <div class="config-desc">å­¦ç¿’å›æ•°ã«ã‚ˆã‚‹å®šç€ã®åŠ¹æœã€‚æ­£ã®å€¤ã€‚</div>
      </label>
      <label class="config-label">
        Beta (å¿˜å´ç‡)
        <input type="number" id="cfgBeta" step="0.01" min="0">
        <div class="config-desc">æ™‚é–“çµŒéã«ã‚ˆã‚‹å¿˜å´ã®åŠ¹æœã€‚æ­£ã®å€¤ã€‚</div>
      </label>

      <!-- GitHubè¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
      <div class="gh-config-section">
        <div style="font-weight:bold; margin-bottom:10px;">GitHubé€£æºè¨­å®š</div>
        <div style="font-size:0.8rem; color:#d32f2f; margin-bottom:10px;">
          â€»ãƒˆãƒ¼ã‚¯ãƒ³ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚ä¿¡é ¼ã§ãã‚‹ç«¯æœ«ã§ã®ã¿å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚
        </div>
        
        <label class="config-label">
          GitHub User Name
          <input type="text" id="cfgGhUser" placeholder="ex: your-username">
        </label>
        <label class="config-label">
          Repository Name
          <input type="text" id="cfgGhRepo" placeholder="ex: anki-app-data">
        </label>
        <label class="config-label">
          Personal Access Token
          <input type="password" id="cfgGhToken" placeholder="ghp_xxxxxxxxxxxx...">
          <div class="config-desc">æ¨©é™ã‚¹ã‚³ãƒ¼ãƒ— <code>repo</code> ãŒå¿…è¦ã§ã™ã€‚</div>
        </label>
      </div>
  
      <div class="modal-actions">
        <button class="btn-secondary" id="configCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button class="btn-primary" id="configSave">ä¿å­˜</button>
      </div>
    </div>
  </div>

  <!-- åŒæœŸï¼ˆMCMCé€£æºï¼‰ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="syncModal" class="modal-overlay hidden">
    <div class="modal-content">
      <div class="modal-title">ãƒ‡ãƒ¼ã‚¿åŒæœŸ (GitHub API)</div>
      <div style="margin-bottom:15px; font-size:0.9rem; color:#666;">
        GitHubãƒªãƒã‚¸ãƒˆãƒªã¨ç›´æ¥é€šä¿¡ã‚’è¡Œã„ã¾ã™ã€‚è¨­å®šç”»é¢ã§ãƒªãƒã‚¸ãƒˆãƒªæƒ…å ±ã¨ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚
      </div>
      
      <div class="sync-area">
        <div style="font-weight:bold; margin-bottom:5px;">1. å­¦ç¿’å±¥æ­´ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</div>
        <div class="sync-desc">
          ç¾åœ¨ã®å­¦ç¿’å±¥æ­´ã‚’GitHubã¸ä¿å­˜ã—ã¾ã™ã€‚
          <br>â€»ä¿å­˜ã•ã‚Œã¦ã„ã‚‹äº‹å®Ÿãƒ‡ãƒ¼ã‚¿(history)ã‹ã‚‰ã€å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã«å¿…è¦ãªå½¢å¼(k, interval)ã‚’å†è¨ˆç®—ã—ã¦ç”Ÿæˆã—ã¾ã™ã€‚
        </div>
        <button class="btn-primary" id="btnUploadHistory">å±¥æ­´ã‚’å†è¨ˆç®—ã—ã¦ä¿å­˜</button>
      </div>

      <div class="sync-area">
        <div style="font-weight:bold; margin-bottom:5px;">2. ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</div>
        <div class="sync-desc">
          GitHubã® <code>data/parameters.json</code> ã‹ã‚‰æœ€æ–°ã®ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—ã—åæ˜ ã—ã¾ã™ã€‚
        </div>
        <button class="btn-secondary" id="btnImportParams">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€</button>
      </div>

      <div class="modal-actions">
        <button class="btn-secondary" id="syncClose">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>

  <!-- ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="debugModal" class="modal-overlay hidden">
    <div class="modal-content" style="max-width: 95%; height: 90vh;">
      <div class="modal-title">IndexedDB Dump (Debug)</div>
      <div style="margin-bottom:5px; font-size:0.8rem; color:#666;">
        ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å†…å®¹ã§ã™ (cards, cardStats, history, reviews)ã€‚
      </div>
      <textarea id="debugText" readonly></textarea>
      <div class="modal-actions">
        <button class="btn-secondary" id="debugClose">é–‰ã˜ã‚‹</button>
        <button class="btn-primary" id="debugRefresh">æ›´æ–°</button>
      </div>
    </div>
  </div>

  <script>
    /* --- 1. å®šæ•°ãƒ»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ --- */
    const DEFAULT_CONFIG = {
      // ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
      MU_BASE: 0.0,
      ALPHA: 0.5,
      BETA: 0.5,
      
      // ã‚¢ãƒ—ãƒªå‹•ä½œè¨­å®š
      LEARNING_THRESHOLD: 5,
      LIKELY_WRONG_LIMIT: 5,
      MASTER_PROB_THRESHOLD: 0.9,
      LEARNING_PROB_THRESHOLD: 0.8,
      CONSECUTIVE_SUCCESS_REQUIRED: 2,
      
      // GitHub Config
      GH_USER: "",
      GH_REPO: "",
      GH_TOKEN: ""
    };

    let CONFIG = { ...DEFAULT_CONFIG };
    try {
      const savedConfig = localStorage.getItem("ankiAppConfig");
      if (savedConfig) {
        const parsed = JSON.parse(savedConfig);
        
        // æ•°å€¤å¤‰æ›ãƒ»äº’æ›æ€§ç¶­æŒ
        if (parsed.MU_BASE !== undefined) CONFIG.MU_BASE = Number(parsed.MU_BASE);
        if (parsed.ALPHA !== undefined) CONFIG.ALPHA = Number(parsed.ALPHA);
        if (parsed.BETA !== undefined) CONFIG.BETA = Number(parsed.BETA);

        if (parsed.LEARNING_THRESHOLD) CONFIG.LEARNING_THRESHOLD = Number(parsed.LEARNING_THRESHOLD);
        if (parsed.LIKELY_WRONG_LIMIT !== undefined) CONFIG.LIKELY_WRONG_LIMIT = Number(parsed.LIKELY_WRONG_LIMIT);
        
        // GitHubè¨­å®šã®èª­ã¿è¾¼ã¿
        if (parsed.GH_USER) CONFIG.GH_USER = parsed.GH_USER;
        if (parsed.GH_REPO) CONFIG.GH_REPO = parsed.GH_REPO;
        if (parsed.GH_TOKEN) CONFIG.GH_TOKEN = parsed.GH_TOKEN;
      }
    } catch(e) { console.error("Config load failed", e); }

    function saveConfig() {
      localStorage.setItem("ankiAppConfig", JSON.stringify(CONFIG));
    }

    /* --- GitHub API Helper --- */
    function utf8_to_b64(str) {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
    
    function b64_to_utf8(str) {
      return decodeURIComponent(escape(window.atob(str)));
    }

    async function githubApiRequest(method, path, body = null) {
      if (!CONFIG.GH_USER || !CONFIG.GH_REPO || !CONFIG.GH_TOKEN) {
        throw new Error("GitHubè¨­å®šï¼ˆUser, Repo, Tokenï¼‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚è¨­å®šç”»é¢ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
      }
      
      const url = `https://api.github.com/repos/${CONFIG.GH_USER}/${CONFIG.GH_REPO}/contents/${path}`;
      const headers = {
        "Authorization": `token ${CONFIG.GH_TOKEN}`,
        "Accept": "application/vnd.github.v3+json",
        "Content-Type": "application/json"
      };
      
      const options = { method, headers };
      if (body) options.body = JSON.stringify(body);

      const res = await fetch(url, options);
      if (!res.ok) {
        const errJson = await res.json();
        throw new Error(`GitHub API Error: ${res.status} ${errJson.message}`);
      }
      return res.json();
    }

    /* --- 2. ãƒ‡ãƒ¼ã‚¿æ§‹é€  --- */
    class Card {
      constructor({ id, numericId, path, question, answer, note = "" }) {
        this.id = id;             // UUID (String)
        this.numericId = numericId; // æ•´æ•°ID (å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ç¶­æŒã€ä¸»ã«è¡¨ç¤ºç”¨)
        this.path = path;
        this.question = question;
        this.answer = answer;
        this.note = note;
      }
    }

    class CardStats {
      constructor(cardId) {
        this.cardId = cardId;
        this.state = "new"; 
        this.lastReviewedAt = null; 
        this.estimatedP = 0.5;
        this.consecutiveHighP = 0;
        this.reviewCount = 0;       
        this.d = 0.0; // Difficulty
        this.a = 1.0; // Discrimination
      }
    }

    /* --- 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š (IndexedDB) --- */
    const DB_NAME = "ankiApp";
    const DB_VERSION = 4; 

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains("cards")) {
            db.createObjectStore("cards", { keyPath: "id" });
          }
          if (!db.objectStoreNames.contains("reviews")) {
            const reviewStore = db.createObjectStore("reviews", { keyPath: "id", autoIncrement: true });
            reviewStore.createIndex("cardId", "cardId", { unique: false });
          }
          if (!db.objectStoreNames.contains("cardStats")) {
            db.createObjectStore("cardStats", { keyPath: "cardId" });
          }
          if (!db.objectStoreNames.contains("history")) {
            const historyStore = db.createObjectStore("history", { keyPath: "id", autoIncrement: true });
            historyStore.createIndex("timestamp", "timestamp", { unique: false });
          }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // ãƒ‡ãƒãƒƒã‚°ç”¨: å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    async function dumpAllData() {
      const db = await openDB();
      const tx = db.transaction(db.objectStoreNames, "readonly");
      const data = {};
      
      for (const storeName of Array.from(db.objectStoreNames)) {
        const store = tx.objectStore(storeName);
        data[storeName] = await new Promise(r => {
           store.getAll().onsuccess = e => r(e.target.result);
        });
      }
      return data;
    }

    async function saveCards(cards) {
      const db = await openDB();
      const tx = db.transaction("cards", "readwrite");
      const store = tx.objectStore("cards");
      const allCards = await new Promise((resolve) => {
          store.getAll().onsuccess = (e) => resolve(e.target.result);
      });
      let maxNumId = 0;
      allCards.forEach(c => { if(c.numericId > maxNumId) maxNumId = c.numericId; });

      const promises = cards.map(card => {
        return new Promise((resolve, reject) => {
          if (!card.numericId) {
             maxNumId++;
             card.numericId = maxNumId;
          }
          const req = store.put(card);
          req.onsuccess = () => resolve();
          req.onerror = () => reject(req.error);
        });
      });
      await Promise.all(promises);
    }

    async function loadCards() {
      const db = await openDB();
      const tx = db.transaction("cards", "readwrite");
      const store = tx.objectStore("cards");
      const cards = await new Promise((resolve, reject) => {
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
      let maxNumId = 0;
      cards.forEach(c => { if(c.numericId > maxNumId) maxNumId = c.numericId; });
      cards.forEach(c => {
          if (!c.numericId) {
              maxNumId++;
              c.numericId = maxNumId;
              store.put(c);
          }
      });
      return cards;
    }

    async function saveStats(stats) {
        const db = await openDB();
        db.transaction("cardStats", "readwrite").objectStore("cardStats").put(stats);
    }

    // å¤‰æ›´: historyã¯æœ€ä½é™ã®äº‹å®Ÿãƒ‡ãƒ¼ã‚¿ã®ã¿ä¿å­˜
    async function recordHistory(entry) {
        const db = await openDB();
        // entry = { item_id, result, timestamp }
        db.transaction("history", "readwrite").objectStore("history").add(entry);
    }

    async function getAllHistory() {
        const db = await openDB();
        return new Promise((resolve) => {
            const req = db.transaction("history", "readonly").objectStore("history").getAll();
            req.onsuccess = () => resolve(req.result);
        });
    }

    /* --- 4. ãƒ­ã‚¸ãƒƒã‚¯ã‚³ã‚¢ (Bayesian Model) --- */
    function sigmoid(x) {
      return 1.0 / (1.0 + Math.exp(-x));
    }

    function calculateP(stats, now) {
      const k = (stats && typeof stats.reviewCount === 'number') ? stats.reviewCount : 0;
      let dt_seconds = 0;
      if (stats.lastReviewedAt) {
          dt_seconds = (now - stats.lastReviewedAt) / 1000; 
      }
      if (dt_seconds < 0) dt_seconds = 0;

      const S = CONFIG.MU_BASE + CONFIG.ALPHA * Math.log(1 + k) - CONFIG.BETA * Math.log(1 + dt_seconds);
      const d = (stats.d !== undefined) ? stats.d : 0.0;
      
      return sigmoid(S - d);
    }

    class Scheduler {
      constructor() {
        this.statsMap = new Map();
        this.cardsMap = new Map();
      }

      async init(cards) {
        this.cardsMap.clear();
        this.statsMap.clear();

        // ãƒ—ãƒ¬ã‚¤å¯¾è±¡ã®ã‚«ãƒ¼ãƒ‰IDã‚’ã‚»ãƒƒãƒˆã«ä¿æŒ
        const activeCardIds = new Set();
        cards.forEach(c => {
            this.cardsMap.set(c.id, c);
            activeCardIds.add(c.id);
        });

        const db = await openDB();
        const tx = db.transaction("cardStats", "readonly");
        const store = tx.objectStore("cardStats");
        const allStats = await new Promise(r => { store.getAll().onsuccess = e => r(e.target.result); });
        
        // ä¿®æ­£: é¸æŠã•ã‚ŒãŸå•é¡Œç¾¤ã«å«ã¾ã‚Œã‚‹ã‚«ãƒ¼ãƒ‰ã®çµ±è¨ˆã®ã¿ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹
        allStats.forEach(s => {
            if (activeCardIds.has(s.cardId)) {
                this.statsMap.set(s.cardId, s);
            }
        });
        
        // çµ±è¨ˆãŒå­˜åœ¨ã—ãªã„ã‚«ãƒ¼ãƒ‰ï¼ˆæ–°è¦ãªã©ï¼‰ã«ã¤ã„ã¦åˆæœŸåŒ–
        cards.forEach(c => {
            if (!this.statsMap.has(c.id)) {
                this.statsMap.set(c.id, new CardStats(c.id));
            }
        });
      }

      async recordResult(cardId, outcome) {
        const now = Date.now();
        const stats = this.statsMap.get(cardId);
        
        // --- å¤‰æ›´ç®‡æ‰€ ---
        // å±¥æ­´DBã«ã¯ã€Œäº‹å®Ÿã€ã®ã¿ä¿å­˜ã™ã‚‹
        // è¨ˆç®—å¯èƒ½ãƒ‡ãƒ¼ã‚¿ï¼ˆk, interval, group_id, numeric_idç­‰ï¼‰ã¯ä¿å­˜ã—ãªã„
        const historyEntry = {
            item_id: cardId, 
            result: (outcome === "correct" ? 1 : 0),
            timestamp: Math.floor(now / 1000)
        };
        await recordHistory(historyEntry);
        // ----------------

        // cardStats (State) ã®æ›´æ–°
        // ã“ã“ã¯é«˜é€ŸåŒ–ã®ãŸã‚ã«ã‚ªãƒ³ãƒ¡ãƒ¢ãƒª/ã‚­ãƒ£ãƒƒã‚·ãƒ¥çš„ã«æ›´æ–°ã—ç¶šã‘ã‚‹
        const k = (stats && typeof stats.reviewCount === 'number') ? stats.reviewCount : 0;
        stats.reviewCount = k + 1;
        stats.lastReviewedAt = now;
        
        const p = calculateP(stats, now);
        stats.estimatedP = p;

        if (stats.state === "new") {
          stats.state = "learning";
          stats.consecutiveHighP = 0;
        }
        if (stats.state === "learning") {
          if (outcome === "correct" && p >= CONFIG.MASTER_PROB_THRESHOLD) {
            stats.consecutiveHighP++;
          } else {
            stats.consecutiveHighP = 0;
          }
          if (stats.consecutiveHighP >= CONFIG.CONSECUTIVE_SUCCESS_REQUIRED) {
            stats.state = "mastered";
            stats.consecutiveHighP = 0;
          }
        } else if (stats.state === "mastered") {
           if (p <= CONFIG.LEARNING_PROB_THRESHOLD) {
             stats.state = "learning";
             stats.consecutiveHighP = 0;
           }
        }
        await saveStats(stats);
      }

      selectNextCard() {
        const now = Date.now();
        const statsList = Array.from(this.statsMap.values());
        statsList.forEach(s => {
            if (s.state !== "new") s.estimatedP = calculateP(s, now);
        });

        if (statsList.length === 0) return null;

        // ãƒªã‚¹ãƒˆã®åˆ†é¡
        const newCards = statsList.filter(s => s.state === "new");
        const learningCards = statsList.filter(s => s.state === "learning");
        const masteredCards = statsList.filter(s => s.state === "mastered");

        // mastered ã‹ã‚‰ã®æ ¼ä¸‹ã’å‡¦ç†
        const degradable = masteredCards.filter(s => s.estimatedP <= CONFIG.LEARNING_PROB_THRESHOLD);
        degradable.forEach(s => {
             s.state = "learning"; 
             learningCards.push(s);
        });

        // ä½ç¢ºç‡ã§é€šå¸¸ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç„¡è¦–ã—ã€æ—¢ç¿’ã‚«ãƒ¼ãƒ‰(learning / mastered)ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ å‡ºé¡Œ
        // CONFIG.RANDOM_REVIEW_CHANCE ã¯ 0.1 (10%) ãªã©ã‚’æƒ³å®š
        if (Math.random() < (CONFIG.RANDOM_REVIEW_CHANCE || 0.1)) {
            // learning ã¨ mastered ã‚’å€™è£œã¨ã—ã¦çµåˆ
            const reviewCandidates = [...learningCards, ...masteredCards];
            
            if (reviewCandidates.length > 0) {
                // ã“ã“ã§è¿”ã›ã°ã€ä»¥é™ã®å„ªå…ˆé †ä½ãƒ­ã‚¸ãƒƒã‚¯ã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã‚‹
                return this.pickRandom(reviewCandidates);
            }
        }


        const likelyWrong = learningCards.filter(s => Math.random() > s.estimatedP);
        
        // --- ä»¥ä¸‹ã€æ—¢å­˜ã®å„ªå…ˆé †ä½ãƒ­ã‚¸ãƒƒã‚¯ ---

        // 1. è„³ã«ä½™è£•ãŒã‚ã‚Œã°æ–°è¦ã‚«ãƒ¼ãƒ‰
        if (likelyWrong.length < CONFIG.LIKELY_WRONG_LIMIT) {
             if (newCards.length > 0) return this.pickRandom(newCards);
        }

        // 2. å¿˜ã‚Œãã†ãªã‚«ãƒ¼ãƒ‰ã‚’æœ€å„ªå…ˆ
        if (likelyWrong.length > 0) return this.pickRandom(likelyWrong);
        
        // 3. é€šå¸¸ã®å­¦ç¿’ä¸­ã‚«ãƒ¼ãƒ‰
        if (learningCards.length > 0) return this.pickRandom(learningCards);
        
        // 4. ã¾ã æ–°è¦ãŒã‚ã‚Œã°ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        if (newCards.length > 0) return this.pickRandom(newCards);
        
        // 5. ç¿’å¾—æ¸ˆã¿ã®ç·å¾©ç¿’
        if (masteredCards.length > 0) {
            masteredCards.sort((a,b) => a.estimatedP - b.estimatedP);
            const candidates = masteredCards.slice(0, Math.min(5, masteredCards.length));
            return this.pickRandom(candidates);
        }
        return null;
      }

      pickRandom(list) {
        const idx = Math.floor(Math.random() * list.length);
        return this.cardsMap.get(list[idx].cardId);
      }
      
      getStats(cardId) {
        return this.statsMap.get(cardId);
      }
    }

    /* --- 5. ãƒ“ãƒ¥ãƒ¼åˆ¶å¾¡ --- */
    const appEl = document.getElementById("app");
    const toolbarEl = document.getElementById("toolbar");

    function setToolbarVisibility(visible) {
      toolbarEl.style.display = visible ? "flex" : "none";
    }

    function createBackButton(onClick) {
      const container = document.createElement("div");
      container.className = "back-button-container";
      const btn = document.createElement("button");
      btn.className = "back-btn";
      btn.textContent = "â† ä¸­æ–­ã—ã¦æˆ»ã‚‹";
      btn.addEventListener("click", onClick);
      container.appendChild(btn);
      return container;
    }

    function createCardView(card, stats, { onSwipe }) {
      const cardEl = document.createElement("div");
      cardEl.className = "card";

      const debugEl = document.createElement("div");
      debugEl.className = "card-stats-debug";
      debugEl.innerHTML = `
        ID: ${card.numericId}<br>
        State: <b>${stats.state}</b> (k=${stats.reviewCount})<br>
        Est. P: ${(stats.estimatedP * 100).toFixed(1)}%<br>
        (d=${stats.d.toFixed(2)})
      `;
      cardEl.appendChild(debugEl);

      const questionEl = document.createElement("div");
      questionEl.className = "question";
      questionEl.textContent = card.question;

      const answerEl = document.createElement("div");
      answerEl.className = "answer hidden";
      answerEl.textContent = card.answer;
      
      if (card.note) {
        const noteEl = document.createElement("div");
        noteEl.style.fontSize = "0.8rem";
        noteEl.style.color = "#888";
        noteEl.style.marginTop = "10px";
        noteEl.textContent = card.note;
        answerEl.appendChild(noteEl);
      }
      
      const guideEl = document.createElement("div");
      guideEl.style.marginTop = "auto";
      guideEl.style.paddingTop = "20px";
      guideEl.style.fontSize = "0.8rem";
      guideEl.style.color = "#ccc";
      guideEl.style.textAlign = "center";
      guideEl.textContent = "ã‚¿ãƒƒãƒ—ã§ç­”ãˆã‚’è¡¨ç¤º / å·¦å³ã‚¹ãƒ¯ã‚¤ãƒ—ã§å›ç­”";
      answerEl.appendChild(guideEl);

      cardEl.append(questionEl, answerEl);
      cardEl.addEventListener("click", () => answerEl.classList.toggle("hidden"));

      let startX = null;
      let startY = null;
      cardEl.addEventListener("pointerdown", (e) => {
        startX = e.clientX;
        startY = e.clientY;
        cardEl.setPointerCapture(e.pointerId);
      });
      cardEl.addEventListener("pointerup", (e) => {
        if (startX === null) return;
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        const threshold = 60;
        
        if (Math.abs(deltaX) > threshold && Math.abs(deltaY) < 60) {
          if (deltaX > 0) onSwipe("correct"); 
          else onSwipe("incorrect");
        }
        startX = null;
        startY = null;
      });
      return cardEl;
    }

    /* --- Path Browser & List View --- */
    function createPathBrowser(tree, handlers) {
      const container = document.createElement("div");
      container.className = "path-browser";
      // ... (çœç•¥ãªã—ã€æ—¢å­˜æ©Ÿèƒ½ç¶­æŒ)
      function renderNode(node, depth = 0) {
        const wrapper = document.createElement("div");
        for (const key of Object.keys(node)) {
          if (key === "__cards__") continue;
          const row = document.createElement("div");
          row.className = "folder-row";
          
          const infoDiv = document.createElement("div");
          infoDiv.className = "folder-info";
          infoDiv.textContent = key;
          infoDiv.style.paddingLeft = `${(depth * 20) + 10}px`;
          
          const childCards = collectCards(node[key]);
          const countSpan = document.createElement("span");
          countSpan.style.float = "right";
          countSpan.style.marginRight = "5px";
          countSpan.style.color = "#999";
          countSpan.style.fontSize = "0.9em";
          countSpan.textContent = `${childCards.length}å•`;
          infoDiv.appendChild(countSpan);
          
          infoDiv.addEventListener("click", () => {
            if (childCards.length === 0) return;
            handlers.onPlay(childCards);
          });
          
          const kebabContainer = document.createElement("div");
          kebabContainer.className = "kebab-container";
          const kebabBtn = document.createElement("div");
          kebabBtn.className = "kebab-btn";
          kebabBtn.textContent = "ï¸™";
          
          const menuPopup = document.createElement("div");
          menuPopup.className = "menu-popup";
          
          const playItem = document.createElement("div");
          playItem.className = "menu-item";
          playItem.textContent = "å­¦ç¿’é–‹å§‹";
          playItem.addEventListener("click", (e) => {
            e.stopPropagation();
            handlers.onPlay(childCards);
            closeAllMenus();
          });
          
          const listItem = document.createElement("div");
          listItem.className = "menu-item";
          listItem.textContent = "å•é¡Œä¸€è¦§";
          listItem.addEventListener("click", (e) => {
            e.stopPropagation();
            handlers.onList(childCards, key);
            closeAllMenus();
          });
          
          menuPopup.append(playItem, listItem);
          kebabContainer.append(kebabBtn, menuPopup);
          
          kebabBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            const isOpen = menuPopup.classList.contains("show");
            closeAllMenus();
            if (!isOpen) menuPopup.classList.add("show");
          });
          
          row.append(infoDiv, kebabContainer);
          wrapper.appendChild(row);
          wrapper.appendChild(renderNode(node[key], depth + 1));
        }
        return wrapper;
      }
      container.appendChild(renderNode(tree));
      return container;
    }

    function closeAllMenus() {
      document.querySelectorAll(".menu-popup.show").forEach(el => el.classList.remove("show"));
    }
    document.addEventListener("click", () => closeAllMenus());

    function buildPathTree(cards) {
      const root = {};
      for (const card of cards) {
        const parts = card.path.split("/");
        let node = root;
        for (const part of parts) {
          if (!node[part]) node[part] = {};
          node = node[part];
        }
        if (!node.__cards__) node.__cards__ = [];
        node.__cards__.push(card);
      }
      return root;
    }

    function collectCards(node) {
      let result = [];
      if (node.__cards__) result = result.concat(node.__cards__);
      for (const key of Object.keys(node)) {
        if (key !== "__cards__") result = result.concat(collectCards(node[key]));
      }
      return result;
    }

    async function importXLSX(file, path) {
      const data = await file.arrayBuffer();
      const workbook = XLSX.read(data);
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      const dataRows = rows.length > 1 ? rows.slice(1) : [];
      
      const cards = dataRows
        .filter(row => row.length > 0 && row[0])
        .map((row, index) => {
          const question = row[0] ? String(row[0]) : "";
          const answer = row[1] ? String(row[1]) : "";
          const note = row[2] ? String(row[2]) : "";
          return new Card({
            id: `${path}-${index}-${crypto.randomUUID()}`,
            numericId: null, // saveCardsã§æ¡ç•ª
            path,
            question,
            answer,
            note
          });
        });
      await saveCards(cards);
      return cards;
    }

    let firstLaunch = false;

    async function showPathSelection() {
      setToolbarVisibility(!firstLaunch);
      firstLaunch = false;
      const cards = await loadCards();
      
      // DEBUG: ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«DBå†…å®¹ã‚’å‡ºåŠ›
      dumpAllData().then(data => {
        console.log("=== IndexedDB Dump (Startup) ===");
        console.log(data);
      });

      appEl.innerHTML = "";

      if (cards.length === 0) {
        const msg = document.createElement("div");
        msg.textContent = "å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚å³ä¸Šã®ãƒœã‚¿ãƒ³ã‹ã‚‰Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚";
        msg.style.padding = "40px 20px";
        msg.style.textAlign = "center";
        appEl.appendChild(msg);
        return;
      }

      const tree = buildPathTree(cards);
      const browser = createPathBrowser(tree, {
        onPlay: (selectedCards) => startSmartQuiz(selectedCards),
        onList: (selectedCards, folderName) => showCardList(selectedCards, folderName)
      });
      appEl.appendChild(browser);
    }

    async function showCardList(cards, title) {
      setToolbarVisibility(false);
      appEl.innerHTML = "<div style='padding:40px; text-align:center;'>èª­ã¿è¾¼ã¿ä¸­...</div>";

      // çµ±è¨ˆæƒ…å ±ã®å–å¾—
      const db = await openDB();
      const tx = db.transaction("cardStats", "readonly");
      const store = tx.objectStore("cardStats");
      const allStats = await new Promise(r => { store.getAll().onsuccess = e => r(e.target.result); });
      
      const statsMap = new Map();
      allStats.forEach(s => statsMap.set(s.cardId, s));

      // çŠ¶æ…‹ã‚«ã‚¦ãƒ³ãƒˆã®é›†è¨ˆ
      let newCount = 0;
      let learningCount = 0;
      let masteredCount = 0;

      cards.forEach(card => {
        const stats = statsMap.get(card.id) || new CardStats(card.id);
        if (stats.state === "mastered") masteredCount++;
        else if (stats.state === "learning") learningCount++;
        else newCount++;
      });

      appEl.innerHTML = "";
      appEl.appendChild(createBackButton(() => showPathSelection()));

      const container = document.createElement("div");
      container.className = "card-list-view";
      const header = document.createElement("div");
      header.className = "list-header";
      header.textContent = `${title} (${cards.length}å•)`;
      container.appendChild(header);

      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚«ã‚¦ãƒ³ãƒˆã®è¡¨ç¤ºã‚¨ãƒªã‚¢
      const statsSummary = document.createElement("div");
      statsSummary.style.display = "flex";
      statsSummary.style.gap = "10px";
      statsSummary.style.marginBottom = "20px";
      statsSummary.style.padding = "10px";
      statsSummary.style.background = "#f9f9f9";
      statsSummary.style.borderRadius = "8px";
      statsSummary.style.fontSize = "0.9rem";

      statsSummary.innerHTML = `
        <span style="color:#666; font-weight:bold;">New: ${newCount}</span>
        <span style="color:#d97706; font-weight:bold;">Learning: ${learningCount}</span>
        <span style="color:#16a34a; font-weight:bold;">Mastered: ${masteredCount}</span>
      `;
      container.appendChild(statsSummary);

      const now = Date.now();

      cards.forEach((card, i) => {
        const item = document.createElement("div");
        item.className = "list-item";
        
        const qDiv = document.createElement("div");
        qDiv.className = "list-q";
        qDiv.textContent = `Q${i+1} [ID:${card.numericId}] ${card.question}`;
        
        const aDiv = document.createElement("div");
        aDiv.className = "list-a";
        aDiv.textContent = `A. ${card.answer}`;
        
        // çµ±è¨ˆæƒ…å ±ã®è¡¨ç¤º
        const stats = statsMap.get(card.id) || new CardStats(card.id);
        
        // ç¾åœ¨æ™‚åˆ»ã«åŸºã¥ã„ãŸPã‚’å†è¨ˆç®—ã—ã¦è¡¨ç¤º
        let currentP = stats.estimatedP;
        if (stats.state !== "new") {
            currentP = calculateP(stats, now);
        }

        const infoDiv = document.createElement("div");
        infoDiv.style.fontSize = "0.75rem";
        infoDiv.style.color = "#3b82f6";
        infoDiv.style.marginTop = "4px";
        infoDiv.style.fontFamily = "monospace";
        infoDiv.innerHTML = `
          State: <b>${stats.state}</b> | 
          k: ${stats.reviewCount} | 
          Est.P: ${(currentP * 100).toFixed(1)}% | 
          d: ${stats.d.toFixed(2)}<br>
          <span style="color:#aaa;">UID: ${card.id.split('-').pop().substring(0,8)}</span>
        `;

        item.appendChild(qDiv);
        item.appendChild(aDiv);
        item.appendChild(infoDiv);
        container.appendChild(item);
      });
      appEl.appendChild(container);
    }

    async function startSmartQuiz(cards) {
      if (!cards || cards.length === 0) return;
      setToolbarVisibility(false);
      appEl.innerHTML = "<div style='padding:40px; text-align:center;'>å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™ä¸­...</div>";

      const scheduler = new Scheduler();
      await scheduler.init(cards);

      function nextLoop() {
        const nextCard = scheduler.selectNextCard();
        if (!nextCard) {
          alert("å‡ºé¡Œå¯èƒ½ãªã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
          showPathSelection();
          return;
        }
        const stats = scheduler.getStats(nextCard.id);
        appEl.innerHTML = "";
        appEl.appendChild(createBackButton(() => showPathSelection()));
        
        const cardView = createCardView(nextCard, stats, {
          onSwipe: async (outcome) => {
            appEl.innerHTML = "<div style='display:flex;height:100%;align-items:center;justify-content:center;font-weight:bold;color:#888;'>Saving...</div>";
            await scheduler.recordResult(nextCard.id, outcome);
            nextLoop();
          }
        });
        appEl.appendChild(cardView);
      }
      nextLoop();
    }

    /* --- ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡ --- */
    const configBtn = document.getElementById("configBtn");
    const configModal = document.getElementById("configModal");
    const configSave = document.getElementById("configSave");
    const configCancel = document.getElementById("configCancel");
    
    configBtn.addEventListener("click", () => {
      document.getElementById("cfgLearningThreshold").value = CONFIG.LEARNING_THRESHOLD;
      document.getElementById("cfgLikelyWrongLimit").value = CONFIG.LIKELY_WRONG_LIMIT;
      
      document.getElementById("cfgMuBase").value = CONFIG.MU_BASE;
      document.getElementById("cfgAlpha").value = CONFIG.ALPHA;
      document.getElementById("cfgBeta").value = CONFIG.BETA;
      
      document.getElementById("cfgGhUser").value = CONFIG.GH_USER;
      document.getElementById("cfgGhRepo").value = CONFIG.GH_REPO;
      document.getElementById("cfgGhToken").value = CONFIG.GH_TOKEN;
      configModal.classList.remove("hidden");
    });
    configCancel.addEventListener("click", () => configModal.classList.add("hidden"));
    configSave.addEventListener("click", () => {
      const lt = parseInt(document.getElementById("cfgLearningThreshold").value, 10);
      const lwl = parseInt(document.getElementById("cfgLikelyWrongLimit").value, 10);
      
      const mu = parseFloat(document.getElementById("cfgMuBase").value);
      const alpha = parseFloat(document.getElementById("cfgAlpha").value);
      const beta = parseFloat(document.getElementById("cfgBeta").value);
      
      const ghUser = document.getElementById("cfgGhUser").value.trim();
      const ghRepo = document.getElementById("cfgGhRepo").value.trim();
      const ghToken = document.getElementById("cfgGhToken").value.trim();

      if (lt > 0) CONFIG.LEARNING_THRESHOLD = lt;
      if (!isNaN(lwl) && lwl >= 0) CONFIG.LIKELY_WRONG_LIMIT = lwl;
      
      if (!isNaN(mu)) CONFIG.MU_BASE = mu;
      if (alpha >= 0) CONFIG.ALPHA = alpha;
      if (beta >= 0) CONFIG.BETA = beta;
      
      CONFIG.GH_USER = ghUser;
      CONFIG.GH_REPO = ghRepo;
      CONFIG.GH_TOKEN = ghToken;
      
      saveConfig();
      alert("è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
      configModal.classList.add("hidden");
    });

    // --- Sync Modal ---
    const syncBtn = document.getElementById("syncBtn");
    const syncModal = document.getElementById("syncModal");
    const syncClose = document.getElementById("syncClose");
    
    syncBtn.addEventListener("click", () => syncModal.classList.remove("hidden"));
    syncClose.addEventListener("click", () => syncModal.classList.add("hidden"));

    // --- Debug Modal ---
    const debugBtn = document.getElementById("debugBtn");
    const debugModal = document.getElementById("debugModal");
    const debugClose = document.getElementById("debugClose");
    const debugRefresh = document.getElementById("debugRefresh");
    const debugText = document.getElementById("debugText");

    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
    debugBtn.addEventListener("click", async () => {
      debugModal.classList.remove("hidden");
      debugText.value = "Loading DB data...";
      const data = await dumpAllData();
      debugText.value = JSON.stringify(data, null, 2);
    });

    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
    debugClose.addEventListener("click", () => {
      debugModal.classList.add("hidden");
    });
    
    // æ›´æ–°ãƒœã‚¿ãƒ³
    debugRefresh.addEventListener("click", async () => {
      debugText.value = "Refreshing...";
      const data = await dumpAllData();
      debugText.value = JSON.stringify(data, null, 2);
    });

    // Upload History to GitHub
    document.getElementById("btnUploadHistory").addEventListener("click", async () => {
        const btn = document.getElementById("btnUploadHistory");
        const originalText = btn.textContent;
        btn.textContent = "ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...";
        btn.disabled = true;

        try {
            // 1. å…¨å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã¨å…¨ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const allHistory = await getAllHistory(); // {item_id, result, timestamp} ã®é…åˆ—
            const allCards = await loadCards();
            
            // ã‚«ãƒ¼ãƒ‰IDã‹ã‚‰æƒ…å ±ã‚’å¼•ã‘ã‚‹ã‚ˆã†ã«MapåŒ–
            const cardMap = new Map();
            allCards.forEach(c => cardMap.set(c.id, c));

            // 2. å±¥æ­´ã‚’item_idã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã€æ™‚ç³»åˆ—é †ã«ã‚½ãƒ¼ãƒˆ
            const historyByItem = {};
            allHistory.forEach(h => {
                if (!historyByItem[h.item_id]) historyByItem[h.item_id] = [];
                historyByItem[h.item_id].push(h);
            });

            // 3. ãƒ‡ãƒ¼ã‚¿å¤‰æ›ãƒ»å†è¨ˆç®— (k, interval_secondsã®ç®—å‡º)
            const exportData = [];
            
            for (const itemId of Object.keys(historyByItem)) {
                const itemHists = historyByItem[itemId];
                // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—é †ã«ã‚½ãƒ¼ãƒˆ
                itemHists.sort((a, b) => a.timestamp - b.timestamp);

                let prevTime = null;
                
                itemHists.forEach((h, index) => {
                    const card = cardMap.get(h.item_id);
                    
                    // k (éå»ã®å­¦ç¿’å›æ•°) = index
                    const k = index; 
                    
                    // delta_t (çµŒéæ™‚é–“)
                    let dt = 0;
                    if (prevTime !== null) {
                        dt = h.timestamp - prevTime;
                    }
                    prevTime = h.timestamp;

                    // ãƒ¢ãƒ‡ãƒ«å­¦ç¿’ã®ãŸã‚ã€k=0 (åˆå›) ã®ãƒ‡ãƒ¼ã‚¿ã¯é™¤å¤–
                    if (k > 0) {
                        exportData.push({
                            item_id: h.item_id,
                            group_id: card ? card.path : "unknown_group",
                            result: h.result,
                            history_count: k,
                            interval_seconds: dt,
                            timestamp: h.timestamp,
                            // å‚è€ƒæƒ…å ±ã¨ã—ã¦å«ã‚ã‚‹ãŒãƒ¢ãƒ‡ãƒ«ã«ã¯å¿…é ˆã§ã¯ãªã„
                            numeric_id: card ? card.numericId : null
                        });
                    }
                });
            }

            // 4. ãƒ‡ãƒ¼ã‚¿ãƒã‚§ãƒƒã‚¯ã¨ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            const totalRawCount = allHistory.length;
            const validExportCount = exportData.length;

            if (validExportCount === 0 && totalRawCount > 0) {
              const msg = `
ç”Ÿãƒ‡ãƒ¼ã‚¿æ•°: ${totalRawCount}ä»¶
ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¯¾è±¡(k>0): 0ä»¶

æœ‰åŠ¹ãªå­¦ç¿’ãƒ‡ãƒ¼ã‚¿(2å›ç›®ä»¥é™ã®å­¦ç¿’)ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
åˆå›å­¦ç¿’ã®ã¿ãŒå­˜åœ¨ã™ã‚‹ã‹ã€ãƒ‡ãƒ¼ã‚¿å½¢å¼ãŒç„¡åŠ¹ã§ã™ã€‚
ç©ºã®ãƒªã‚¹ãƒˆã¨ã—ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã‹ï¼Ÿ
              `.trim();
              if(!confirm(msg)) {
                 throw new Error("ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ");
              }
            }

            const jsonStr = JSON.stringify(exportData, null, 2);
            const contentBase64 = utf8_to_b64(jsonStr);
            const path = "data/history.json";

            // Get current SHA
            let sha = null;
            try {
                const res = await githubApiRequest("GET", path);
                sha = res.sha;
            } catch (e) {
                console.log("File likely doesn't exist yet", e);
            }

            // Put
            const body = {
                message: `Update history.json (Computed ${validExportCount} valid records from ${totalRawCount} raw logs)`,
                content: contentBase64
            };
            if (sha) body.sha = sha;

            await githubApiRequest("PUT", path, body);
            
            alert(`å±¥æ­´ã‚’GitHubã¸ä¿å­˜ã—ã¾ã—ãŸã€‚\nDBä¸Šã®ç”Ÿãƒ­ã‚°${totalRawCount}ä»¶ã‹ã‚‰ã€${validExportCount}ä»¶ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿(k>0)ã‚’ç”Ÿæˆã—ã¦é€ä¿¡ã—ã¾ã—ãŸã€‚`);
        } catch (err) {
            console.error(err);
            alert("ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—: " + err.message);
        } finally {
            btn.textContent = originalText;
            btn.disabled = false;
        }
    });

    // Import Params from GitHub
    document.getElementById("btnImportParams").addEventListener("click", async () => {
        const btn = document.getElementById("btnImportParams");
        const originalText = btn.textContent;
        btn.textContent = "èª­ã¿è¾¼ã¿ä¸­...";
        btn.disabled = true;

        try {
            const path = "data/parameters.json";
            const res = await githubApiRequest("GET", path);
            const jsonStr = b64_to_utf8(res.content);
            const params = JSON.parse(jsonStr);

            let updated = false;

            // 1. Global Parameters
            if (params.global_parameters) {
                const g = params.global_parameters;
                if (g.mu_base !== undefined) CONFIG.MU_BASE = g.mu_base;
                if (g.alpha !== undefined) CONFIG.ALPHA = g.alpha;
                if (g.beta !== undefined) CONFIG.BETA = g.beta;
                updated = true;
            }
            
            // 2. Item Difficulties
            if (params.item_difficulties) {
                const db = await openDB();
                const tx = db.transaction(["cards", "cardStats"], "readwrite");
                const cardStore = tx.objectStore("cards");
                const statStore = tx.objectStore("cardStats");
                
                // å…¨ã‚«ãƒ¼ãƒ‰ã¨å…¨çµ±è¨ˆã‚’å–å¾—
                const stats = await new Promise(r => { statStore.getAll().onsuccess = e => r(e.target.result); });
                const statsMap = new Map();
                stats.forEach(s => statsMap.set(s.cardId, s));
                
                let updateCount = 0;
                
                // item_difficultiesã®ã‚­ãƒ¼ã¯Pythonå´ã§ item_id (String) ã¨ã—ã¦ä¿å­˜ã•ã‚Œã¦ã„ã‚‹
                for (const [itemId, difficulty] of Object.entries(params.item_difficulties)) {
                    // è©²å½“ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã®çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
                    let s = statsMap.get(itemId);
                    if (!s) s = new CardStats(itemId); // å­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
                    
                    s.d = difficulty;
                    statStore.put(s);
                    updateCount++;
                }
                
                saveConfig();
                alert(`ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚\næ›´æ–°ä»¶æ•°: ${updateCount}\n\n[Global]\nMu Base: ${CONFIG.MU_BASE.toFixed(2)}\nAlpha: ${CONFIG.ALPHA.toFixed(2)}\nBeta: ${CONFIG.BETA.toFixed(2)}`);
                
                syncModal.classList.add("hidden");
                showPathSelection(); // Refresh UI
            } else {
                alert("ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ (item_difficulties not found)");
            }
        } catch (err) {
            console.error(err);
            alert("èª­ã¿è¾¼ã¿å¤±æ•—: " + err.message);
        } finally {
            btn.textContent = originalText;
            btn.disabled = false;
        }
    });

    // Event Init
    tsvInput.addEventListener("change", async e => {
      const file = e.target.files[0];
      if (!file) return;
      const path = prompt("ã“ã®å•é¡Œç¾¤ã®ãƒ•ã‚©ãƒ«ãƒ€åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: è‹±èª/è‹±å˜èª/Part1ï¼‰");
      if (!path) { tsvInput.value = ""; return; }
      try {
        await importXLSX(file, path);
        tsvInput.value = "";
        showPathSelection();
      } catch (err) {
        console.error(err);
        alert("èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ");
      }
    });

    showPathSelection();
  </script>
</body>
</html>